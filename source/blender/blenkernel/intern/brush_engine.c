#include "MEM_guardedalloc.h"

#include "BLI_alloca.h"
#include "BLI_array.h"
#include "BLI_bitmap.h"
#include "BLI_compiler_attrs.h"
#include "BLI_compiler_compat.h"
#include "BLI_ghash.h"
#include "BLI_listbase.h"
#include "BLI_math.h"
#include "BLI_memarena.h"
#include "BLI_mempool.h"
#include "BLI_rect.h"
#include "BLI_smallhash.h"

#include "DNA_brush_enums.h"
#include "DNA_brush_types.h"
#include "DNA_color_types.h"
#include "DNA_curveprofile_types.h"
#include "DNA_material_types.h"
#include "DNA_node_types.h"
#include "DNA_sculpt_brush_types.h"

#include "BKE_brush.h"
#include "BKE_colorband.h"
#include "BKE_colortools.h"
#include "BKE_context.h"
#include "BKE_node.h"
#include "BKE_paint.h"

#include "BKE_brush_engine.h"
#include "BKE_curveprofile.h"

#include "BLO_read_write.h"

static struct {
  char tag[4192];
} namestack[256] = {0};
int namestack_i = 1;

ATTR_NO_OPT void namestack_push(const char *name)
{
  namestack_i++;

  strcpy(namestack[namestack_i].tag, namestack[namestack_i - 1].tag);
  strcat(namestack[namestack_i].tag, ".");
  strcat(namestack[namestack_i].tag, name);
}
void namestack_pop()
{
  namestack_i--;
}
#define namestack_head_name strdup(namestack[namestack_i].tag)

void BKE_curvemapping_copy_data_tag_ex(CurveMapping *target,
                                       const CurveMapping *cumap,
                                       const char *tag);

#define BKE_curvemapping_copy_data(dst, src) \
  BKE_curvemapping_copy_data_tag_ex(dst, src, namestack_head_name)

static bool check_corrupted_curve(BrushMapping *dst)
{

  const float clip_size_x = BLI_rctf_size_x(&dst->curve.curr);
  const float clip_size_y = BLI_rctf_size_y(&dst->curve.curr);

  // fix corrupted curve
  if (clip_size_x == 0.0f || clip_size_y == 0.0f) {
    for (int i = 0; i < 4; i++) {
      BKE_curvemapping_free_data(&dst->curve);
      memset(&dst->curve, 0, sizeof(CurveMapping));

      BKE_curvemapping_set_defaults(&dst->curve, 1, 0.0, 0.0, 1.0, 1.0);

      BKE_curvemap_reset(&dst->curve.cm[i],
                         &(struct rctf){.xmin = 0, .ymin = 0.0, .xmax = 1.0, .ymax = 1.0},
                         CURVE_PRESET_LINE,
                         dst->flag & BRUSH_MAPPING_INVERT);
      BKE_curvemapping_init(&dst->curve);
    }

    return false;
  }

  return true;
}

/*
Brush command lists.

Command lists are built dynamically from
brush flags, pen input settings, etc.

Eventually they will be generated by node
networks.  BrushCommandPreset will be
generated from the node group inputs.
*/

extern BrushChannelType brush_builtin_channels[];
extern const int brush_builtin_channel_len;

void BKE_brush_channel_free(BrushChannel *ch)
{
  for (int i = 0; i < BRUSH_MAPPING_MAX; i++) {
    BKE_curvemapping_free_data(&ch->mappings[i].curve);
  }
}

ATTR_NO_OPT void BKE_brush_channel_copy_data(BrushChannel *dst, BrushChannel *src)
{
  // we have to free old curvemappings here,
  // before the *dst = *src, otherwise the new
  // curves will be freed in BKE_brush_mapping_copy_data
  for (int i = 0; i < BRUSH_MAPPING_MAX; i++) {
    BKE_curvemapping_free_data(&dst->mappings[i].curve);
  }

  *dst = *src;

  // clear curves in dst, see comment above
  for (int i = 0; i < BRUSH_MAPPING_MAX; i++) {
    memset(&dst->mappings[i].curve, 0, sizeof(CurveMapping));
  }

  namestack_push(__func__);

  for (int i = 0; i < BRUSH_MAPPING_MAX; i++) {
    BKE_brush_mapping_copy_data(dst->mappings + i, src->mappings + i);
    dst->mappings[i].type = i;
  }

  namestack_pop();
}

ATTR_NO_OPT void BKE_brush_channel_init(BrushChannel *ch, BrushChannelType *def)
{
  memset(ch, 0, sizeof(*ch));

  strcpy(ch->name, def->name);
  strcpy(ch->idname, def->idname);

  ch->flag = def->flag;
  ch->fvalue = def->fvalue;
  ch->ivalue = def->ivalue;

  ch->type = def->type;
  ch->def = def;

  for (int i = 0; i < BRUSH_MAPPING_MAX; i++) {
    BrushMapping *map = ch->mappings + i;
    CurveMapping *curve = &map->curve;

    map->type = i;

    BKE_curvemapping_free_data(curve);
    memset(curve, 0, sizeof(*curve));

    float min, max;

    BrushMappingDef *mdef = (&def->mappings.pressure) + i;

    if (mdef->min != mdef->max) {
      min = mdef->min;
      max = mdef->max;
    }
    else {
      min = 0.0f;
      max = 1.0f;
    }

    if (mdef->inv) {
      ch->mappings[i].flag |= BRUSH_MAPPING_INVERT;
    }

    int slope = CURVEMAP_SLOPE_POSITIVE;

    BKE_curvemapping_set_defaults(curve, 1, 0, min, 1, max);

    for (int i = 0; i < 4; i++) {
      BKE_curvemap_reset(&curve->cm[i],
                         &(struct rctf){.xmin = 0, .ymin = min, .xmax = 1, .ymax = max},
                         mdef->curve,
                         slope);
    }

    BKE_curvemapping_init(curve);

    map->blendmode = mdef->blendmode;
    map->factor = mdef->factor == 0.0f ? 1.0f : mdef->factor;

    if (mdef->enabled) {
      map->flag |= BRUSH_MAPPING_ENABLED;
    }
  }
}

BrushChannelSet *BKE_brush_channelset_create()
{
  return (BrushChannelSet *)MEM_callocN(sizeof(BrushChannelSet), "BrushChannelSet");
}

void BKE_brush_apply_queued_channels(BrushChannelSet *chset, bool do_override)
{
  if (!chset->tot_queued_channel) {
    return;
  }

  for (int i = 0; i < chset->tot_queued_channel; i++) {
    BrushChannel *ch = chset->queued_channels;

    BrushChannel *exist = BKE_brush_channelset_lookup(chset, ch->idname);

    if (exist) {
      if (!do_override) {
        continue;
      }

      BKE_brush_channel_free(exist);
      *exist = *ch;

      continue;
    }
    else {
      BKE_brush_channelset_add(chset, ch);
      BKE_brush_channel_free(ch);
    }
  }

  MEM_SAFE_FREE(chset->queued_channels);
  chset->queued_channels = NULL;
  chset->tot_queued_channel = NULL;
}

void BKE_brush_channelset_free(BrushChannelSet *chset)
{
  for (int step = 0; step < 2; step++) {
    BrushChannel *channels = step ? chset->queued_channels : chset->channels;
    int totchannel = step ? chset->tot_queued_channel : chset->totchannel;

    if (channels) {
      for (int i = 0; i < totchannel; i++) {
        BKE_brush_channel_free(channels + i);
      }

      MEM_freeN(channels);
    }
  }

  MEM_freeN(chset);
}

void BKE_brush_channelset_add(BrushChannelSet *chset, BrushChannel *ch)
{
  chset->totchannel++;

  if (!chset->channels) {
    chset->channels = MEM_callocN(sizeof(BrushChannel) * chset->totchannel, "chset->channels");
  }
  else {
    chset->channels = MEM_recallocN_id(
        chset->channels, sizeof(BrushChannel) * chset->totchannel, "chset->channels");
  }

  namestack_push(__func__);
  BKE_brush_channel_copy_data(chset->channels + chset->totchannel - 1, ch);
  namestack_pop();
}

// used to avoid messing up pointers in ui
void BKE_brush_channelset_queue(BrushChannelSet *chset, BrushChannel *ch)
{
  chset->tot_queued_channel++;

  if (!chset->queued_channels) {
    chset->queued_channels = MEM_callocN(sizeof(BrushChannel) * chset->tot_queued_channel,
                                         "chset->channels");
  }
  else {
    chset->queued_channels = MEM_recallocN_id(chset->queued_channels,
                                              sizeof(BrushChannel) * chset->tot_queued_channel,
                                              "chset->queued_channels");
  }

  namestack_push(__func__);
  BKE_brush_channel_copy_data(chset->queued_channels + chset->tot_queued_channel - 1, ch);
  namestack_pop();
}

ATTR_NO_OPT BrushChannel *BKE_brush_channelset_lookup(BrushChannelSet *chset, const char *idname)
{
  for (int i = 0; i < chset->totchannel; i++) {
    if (STREQ(chset->channels[i].idname, idname)) {
      return chset->channels + i;
    }
  }

  return NULL;
}

bool BKE_brush_channelset_has(BrushChannelSet *chset, const char *idname)
{
  return BKE_brush_channelset_lookup(chset, idname) != NULL;
}

BrushChannelType brush_default_channel_type = {
    .name = "Channel",
    .idname = "CHANNEL",
    .min = 0.0f,
    .max = 1.0f,
    .soft_min = 0.0f,
    .soft_max = 1.0f,
    .type = BRUSH_CHANNEL_FLOAT,
    .flag = 0,
    .ivalue = 0,
    .fvalue = 0.0f,
    .mappings = {.pressure = {.curve = CURVE_PRESET_LINE,
                              .enabled = false,
                              .inv = false,
                              .blendmode = MA_RAMP_BLEND}}};

BrushChannelType *BKE_brush_default_channel_def()
{
  return &brush_default_channel_type;
}

void BKE_brush_channel_def_copy(BrushChannelType *dst, BrushChannelType *src)
{
  *dst = *src;
}

ATTR_NO_OPT BrushChannelType *BKE_brush_builtin_channel_def_find(const char *name)
{
  for (int i = 0; i < brush_builtin_channel_len; i++) {
    BrushChannelType *def = brush_builtin_channels + i;

    if (STREQ(def->idname, name)) {
      return def;
    }
  }

  return NULL;
}

ATTR_NO_OPT void BKE_brush_channelset_add_builtin(BrushChannelSet *chset, const char *idname)
{
  BrushChannelType *def = BKE_brush_builtin_channel_def_find(idname);

  if (!def) {
    printf("%s: Could not find brush %s\n", __func__, idname);
    return;
  }

  BrushChannel ch = {0};

  namestack_push(__func__);

  BKE_brush_channel_init(&ch, def);
  BKE_brush_channelset_add(chset, &ch);
  BKE_brush_channel_free(&ch);

  namestack_pop();
}

bool BKE_brush_channelset_ensure_builtin(BrushChannelSet *chset, const char *idname)
{
  namestack_push(__func__);

  if (!BKE_brush_channelset_has(chset, idname)) {
    BKE_brush_channelset_add_builtin(chset, idname);
    namestack_pop();
    return true;
  }

  namestack_pop();
  return false;
}

void BKE_brush_channelset_ensure_existing(BrushChannelSet *chset,
                                          BrushChannel *existing,
                                          bool queue)
{
  if (BKE_brush_channelset_has(chset, existing->idname)) {
    return;
  }

  namestack_push(__func__);
  if (!queue) {
    BKE_brush_channelset_add(chset, existing);
  }
  else {
    BKE_brush_channelset_queue(chset, existing);
  }

  namestack_pop();
}
#define ADDCH(name) BKE_brush_channelset_ensure_builtin(chset, name)
#define GETCH(name) BKE_brush_channelset_lookup(chset, name)

ATTR_NO_OPT void BKE_brush_channelset_merge(BrushChannelSet *dst,
                                            BrushChannelSet *child,
                                            BrushChannelSet *parent)
{
  // first add missing channels
  namestack_push(__func__);

  for (int step = 0; step < 2; step++) {
    BrushChannelSet *chset = step ? parent : child;

    for (int i = 0; i < chset->totchannel; i++) {
      BrushChannel *ch = chset->channels + i;
      BrushChannel *ch2 = BKE_brush_channelset_lookup(dst, ch->idname);

      if (ch2 && step > 0) {
        continue;
      }

      if (!ch2) {
        BrushChannel ch3 = {0};

        BKE_brush_channel_copy_data(&ch3, ch);
        BKE_brush_channelset_add(dst, &ch3);

        BKE_brush_channel_free(&ch3);
      }
      else {
        BKE_brush_channel_copy_data(ch2, ch);
      }
    }
  }

  for (int i = 0; i < parent->totchannel; i++) {
    BrushChannel *pch = parent->channels + i;
    BrushChannel *mch = BKE_brush_channelset_lookup(dst, pch->idname);
    BrushChannel *ch = BKE_brush_channelset_lookup(child, pch->idname);

    if (!ch) {
      continue;
    }

    if (ch->flag & BRUSH_CHANNEL_INHERIT) {
      BKE_brush_channel_copy_data(mch, pch);
      continue;
    }

    if (ch->type == BRUSH_CHANNEL_BITMASK && (ch->flag & BRUSH_CHANNEL_INHERIT_IF_UNSET)) {
      mch->ivalue = ch->ivalue | pch->ivalue;
    }
  }

  namestack_pop();
}

BrushChannelSet *BKE_brush_channelset_copy(BrushChannelSet *src)
{
  BrushChannelSet *chset = BKE_brush_channelset_create();

  *chset = *src;

  if (!chset->totchannel) {
    return chset;
  }

  namestack_push(__func__);

  chset->channels = MEM_calloc_arrayN(
      src->totchannel, sizeof(BrushChannel), "chset->channels copied");

  for (int i = 0; i < chset->totchannel; i++) {
    BrushChannel *ch = chset->channels + i;

    BKE_brush_channel_copy_data(ch, src->channels + i);
  }

  namestack_pop();

  return chset;
}

void BKE_brush_commandlist_start(BrushCommandList *list,
                                 Brush *brush,
                                 BrushChannelSet *chset_final)
{
  for (int i = 0; i < list->totcommand; i++) {
    BrushCommand *cmd = list->commands + i;

    // Build final list of command parameters
    if (cmd->params_final) {
      BKE_brush_channelset_free(cmd->params_final);
    }
    cmd->params_final = BKE_brush_channelset_create();

    BKE_brush_channelset_merge(cmd->params_final, cmd->params, chset_final);
  }
}

void BKE_brush_resolve_channels(Brush *brush, Sculpt *sd)
{
  if (brush->channels_final) {
    BKE_brush_channelset_free(brush->channels_final);
  }

  brush->channels_final = BKE_brush_channelset_create();

  BKE_brush_channelset_merge(brush->channels_final, brush->channels, sd->channels);
}

int BKE_brush_channelset_get_int(BrushChannelSet *chset, char *idname)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(chset, idname);

  if (!ch) {
    printf("%s, unknown channel %s", __func__, idname);
    return 0;
  }

  return ch->ivalue;
}

float BKE_brush_channelset_get_final_float(BrushChannelSet *brushset,
                                           BrushChannelSet *toolset,
                                           char *idname,
                                           BrushMappingData *mapdata)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(brushset, idname);

  if (!ch || (ch->flag & BRUSH_CHANNEL_INHERIT)) {
    BrushChannel *pch = BKE_brush_channelset_lookup(toolset, idname);

    if (pch) {
      return BKE_brush_channel_get_float(pch, mapdata);
    }
  }

  if (ch) {
    return BKE_brush_channel_get_float(ch, mapdata);
  }

  printf("%s: failed to find brush channel %s\n", __func__, idname);

  return 0.0f;
}

void BKE_brush_channelset_set_final_float(BrushChannelSet *brushset,
                                          BrushChannelSet *toolset,
                                          char *idname,
                                          float value)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(brushset, idname);

  if (!ch || (ch->flag & BRUSH_CHANNEL_INHERIT)) {
    BrushChannel *pch = BKE_brush_channelset_lookup(toolset, idname);

    if (pch) {
      BKE_brush_channel_set_float(pch, value);
      return;
    }
  }

  if (!ch) {
    printf("%s: failed to find brush channel %s\n", __func__, idname);
    return;
  }

  BKE_brush_channel_set_float(ch, value);
}

float BKE_brush_channelset_get_float(BrushChannelSet *chset,
                                     char *idname,
                                     BrushMappingData *mapdata)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(chset, idname);

  if (!ch) {
    printf("%s, unknown channel %s", __func__, idname);
    return 0.0f;
  }

  return BKE_brush_channel_get_float(ch, mapdata);
}

float BKE_brush_channel_get_float(BrushChannel *ch, BrushMappingData *mapdata)
{

  float f = ch->fvalue;

  if (mapdata) {
    float map = f;

    for (int i = 0; i < BRUSH_MAPPING_MAX; i++) {
      BrushMapping *mp = ch->mappings + i;

      if (!(mp->flag & BRUSH_MAPPING_ENABLED)) {
        continue;
      }

      float f2 = BKE_curvemapping_evaluateF(&mp->curve, 0, f);
      switch (mp->blendmode) {
        case MA_RAMP_BLEND:
          break;
        case MA_RAMP_MULT:
          f2 *= f;
          break;
        case MA_RAMP_DIV:
          f2 = f / (0.00001f + f);
          break;
        case MA_RAMP_ADD:
          f2 += f;
          break;
        case MA_RAMP_SUB:
          f2 = f - f2;
          break;
        case MA_RAMP_DIFF:
          f2 = fabsf(f - f2);
          break;
        default:
          printf("Unsupported brush mapping blend mode for %s (%s); will mix instead\n",
                 ch->name,
                 ch->idname);
          break;
      }

      f += (f2 - f) * mp->factor;
    }
  }

  return f;
}

void BKE_brush_channel_set_float(BrushChannel *ch, float val)
{
  ch->fvalue = val;
}

bool BKE_brush_channelset_set_float(BrushChannelSet *chset, char *idname, float val)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(chset, idname);

  if (!ch) {
    printf("%s, unknown channel %s", __func__, idname);
    return 0;
  }

  BKE_brush_channel_set_float(ch, val);

  return true;
}

void BKE_brush_init_toolsettings(Sculpt *sd)
{
  namestack_push(__func__);

  if (sd->channels) {
    BKE_brush_channelset_free(sd->channels);
  }

  BrushChannelSet *chset = sd->channels = BKE_brush_channelset_create();

  ADDCH("RADIUS");
  ADDCH("STRENGTH");
  ADDCH("AUTOMASKING");
  ADDCH("TOPOLOGY_RAKE_MODE");
  ADDCH("DYNTOPO_DISABLED");
  ADDCH("DYNTOPO_DETAIL_RANGE");

  namestack_pop();
}

void BKE_brush_channelset_flag_clear(BrushChannelSet *chset, const char *channel, int flag)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(chset, channel);

  if (!ch) {
    printf("%s: unknown channel '%s'\n", __func__, channel);
    return;
  }

  ch->flag &= ~flag;
}

void BKE_brush_channelset_flag_set(BrushChannelSet *chset, const char *channel, int flag)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(chset, channel);

  if (!ch) {
    printf("%s: unknown channel '%s'\n", __func__, channel);
    return;
  }

  ch->flag |= flag;
}

// adds any missing channels to brushes
void BKE_brush_builtin_patch(Brush *brush, int tool)
{
  namestack_push(__func__);

  if (!brush->channels) {
    brush->channels = BKE_brush_channelset_create();
  }

  BrushChannelSet *chset = brush->channels;

  ADDCH("RADIUS");
  ADDCH("SPACING");
  ADDCH("STRENGTH");

  ADDCH("AUTOSMOOTH");
  ADDCH("AUTOSMOOTH_RADIUS_SCALE");
  ADDCH("AUTOSMOOTH_SPACING");
  ADDCH("AUTOSMOOTH_USE_SPACING");
  ADDCH("AUTOSMOOTH_PROJECTION");

  ADDCH("TOPOLOGY_RAKE");
  ADDCH("TOPOLOGY_RAKE_MODE");
  ADDCH("TOPOLOGY_RAKE_RADIUS_SCALE");
  ADDCH("TOPOLOGY_RAKE_USE_SPACING");
  ADDCH("TOPOLOGY_RAKE_SPACING");
  ADDCH("TOPOLOGY_RAKE_PROJECTION");

  ADDCH("HARDNESS");
  ADDCH("TIP_ROUNDNESS");
  ADDCH("NORMAL_RADIUS_FACTOR");

  ADDCH("AUTOMASKING");

  ADDCH("DYNTOPO_DISABLED");
  ADDCH("DYNTOPO_DETAIL_RANGE");
  ADDCH("DYNTOPO_OPS");

  ADDCH("ACCUMULATE");
  ADDCH("ORIGINAL_NORMAL");
  ADDCH("ORIGINAL_PLANE");
  ADDCH("JITTER");
  ADDCH("JITTER_ABSOLUTE");
  ADDCH("USE_WEIGHTED_SMOOTH");
  ADDCH("PRESERVE_FACESET_BOUNDARY");
  ADDCH("HARD_EDGE_MODE");
  ADDCH("GRAB_SILHOUETTE");

  ADDCH("PROJECTION");
  ADDCH("BOUNDARY_SMOOTH");
  ADDCH("FSET_SLIDE");

  switch (tool) {
    case SCULPT_TOOL_DRAW: {
      break;
    }
    case SCULPT_TOOL_SLIDE_RELAX:
      ADDCH("SLIDE_DEFORM_TYPE");
      break;
  }

  namestack_pop();
}

void BKE_brush_init_scene_defaults(Sculpt *sd)
{
  if (!sd->channels) {
    sd->channels = BKE_brush_channelset_create();
  }

  BrushChannelSet *chset = sd->channels;
}

void BKE_brush_builtin_create(Brush *brush, int tool)
{
  namestack_push(__func__);

  if (!brush->channels) {
    brush->channels = BKE_brush_channelset_create();
  }

  BrushChannelSet *chset = brush->channels;

  BKE_brush_builtin_patch(brush, tool);

  GETCH("STRENGTH")->flag |= BRUSH_CHANNEL_INHERIT;
  GETCH("RADIUS")->flag |= BRUSH_CHANNEL_INHERIT;

  switch (tool) {
    case SCULPT_TOOL_DRAW: {
      break;
    }
    case SCULPT_TOOL_DRAW_SHARP:
      GETCH("SPACING")->ivalue = 5;
      GETCH("RADIUS")->mappings[BRUSH_MAPPING_PRESSURE].blendmode = true;
      break;
    case SCULPT_TOOL_DISPLACEMENT_ERASER:
    case SCULPT_TOOL_FAIRING:
    case SCULPT_TOOL_SCENE_PROJECT:
      GETCH("SPACING")->ivalue = 10;
      GETCH("STRENGTH")->fvalue = 1.0f;
      GETCH("DYNTOPO_DISABLED")->ivalue = 1;
      break;
    case SCULPT_TOOL_SLIDE_RELAX:
      GETCH("SPACING")->ivalue = 10;
      GETCH("STRENGTH")->fvalue = 1.0f;
      GETCH("DYNTOPO_DISABLED")->ivalue = 1;
      GETCH("SLIDE_DEFORM_TYPE")->ivalue = BRUSH_SLIDE_DEFORM_DRAG;
      break;
    case SCULPT_TOOL_CLAY:
      GETCH("RADIUS")->mappings[BRUSH_MAPPING_PRESSURE].flag |= BRUSH_MAPPING_ENABLED;
      GETCH("SPACING")->ivalue = 3;
      GETCH("AUTOSMOOTH")->fvalue = 0.25f;
      GETCH("NORMAL_RADIUS_FACTOR")->fvalue = 0.75f;
      GETCH("HARDNESS")->fvalue = 0.65;
      break;
    case SCULPT_TOOL_TWIST:
      GETCH("STRENGTH")->fvalue = 0.5f;
      GETCH("NORMAL_RADIUS_FACTOR")->fvalue = 1.0f;
      GETCH("SPACING")->ivalue = 6;
      GETCH("HARDNESS")->fvalue = 0.5;
      break;
    case SCULPT_TOOL_CLAY_STRIPS: {
      GETCH("RADIUS")->mappings[BRUSH_MAPPING_PRESSURE].flag |= BRUSH_MAPPING_ENABLED;
      GETCH("TIP_ROUNDNESS")->fvalue = 0.18f;
      GETCH("NORMAL_RADIUS_FACTOR")->fvalue = 1.35f;
      GETCH("STRENGTH")->fvalue = 0.8f;
      GETCH("ACCUMULATE")->ivalue = 1;

      CurveMapping *curve = &GETCH("RADIUS")->mappings[BRUSH_MAPPING_PRESSURE].curve;
      CurveMap *cuma = curve->cm;

      cuma->curve[0].x = 0.0f;
      cuma->curve[0].y = 0.55f;
      BKE_curvemap_insert(cuma, 0.5f, 0.7f);
      cuma->curve[2].x = 1.0f;
      cuma->curve[2].y = 1.0f;
      BKE_curvemapping_changed(curve, true);

      cuma = curve->cm;
      BKE_curvemap_insert(cuma, 0.6f, 0.25f);
      BKE_curvemapping_changed(curve, true);

      break;
    }
    default: {
      // implement me!
      // BKE_brush_channelset_free(chset);
      // brush->channels = NULL;
      break;
    }
  }

  namestack_pop();
}

#ifdef FLOAT
#  undef FLOAT
#endif
#ifdef INT
#  undef INT
#endif
#ifdef BOOL
#  undef BOOL
#endif

#define FLOAT BRUSH_CHANNEL_FLOAT
#define INT BRUSH_CHANNEL_INT
#define BOOL BRUSH_CHANNEL_BOOL
#define FLOAT3 BRUSH_CHANNEL_VEC3
#define FLOAT4 BRUSH_CHANNEL_VEC4

/* clang-format off */
#define DEF(brush_member, channel_name, btype, ctype) \
  {offsetof(Brush, brush_member), #channel_name, btype, ctype, sizeof(((Brush){0}).brush_member)},
/* clang-format on */

typedef struct BrushSettingsMap {
  int brush_offset;
  const char *channel_name;
  int brush_type;
  int channel_type;
  int member_size;
} BrushSettingsMap;

/* clang-format off */
static BrushSettingsMap brush_settings_map[] = {
  DEF(size, RADIUS, INT, FLOAT)
  DEF(alpha, STRENGTH, FLOAT, FLOAT)
  DEF(autosmooth_factor, AUTOSMOOTH, FLOAT, FLOAT)
  DEF(autosmooth_projection, SMOOTH_PROJECTION, FLOAT, FLOAT)
  DEF(topology_rake_projection, TOPOLOGY_RAKE_PROJECTION, FLOAT, FLOAT)
  DEF(topology_rake_radius_factor, TOPOLOGY_RAKE_RADIUS_SCALE, FLOAT, FLOAT)
  DEF(topology_rake_spacing, TOPOLOGY_RAKE_SPACING, INT, FLOAT)
  DEF(topology_rake_factor, TOPOLOGY_RAKE, FLOAT, FLOAT)
  DEF(autosmooth_fset_slide, FSET_SLIDE, FLOAT, FLOAT)
  DEF(boundary_smooth_factor, BOUNDARY_SMOOTH, FLOAT, FLOAT)
  DEF(autosmooth_radius_factor, AUTOSMOOTH_RADIUS_SCALE, FLOAT, FLOAT)
  DEF(normal_weight, NORMAL_WEIGHT, FLOAT, FLOAT)
  DEF(rake_factor, RAKE_FACTOR, FLOAT, FLOAT)
  DEF(weight, WEIGHT, FLOAT, FLOAT)
  DEF(jitter, JITTER, FLOAT, FLOAT)
  DEF(jitter_absolute, JITTER_ABSOLITE, INT, INT)
  DEF(smooth_stroke_radius, SMOOTH_STROKE_RADIUS, INT, FLOAT)
  DEF(smooth_stroke_factor, SMOOTH_STROKE_FACTOR, FLOAT, FLOAT)
  DEF(rate, RATE, FLOAT, FLOAT)
  DEF(flow, FLOW, FLOAT, FLOAT)
  DEF(wet_mix, WET_MIX, FLOAT, FLOAT)
  DEF(wet_persistence, WET_PERSISTENCE, FLOAT, FLOAT)
  DEF(density, DENSITY, FLOAT, FLOAT)
  DEF(tip_scale_x, TIP_SCALE_X, FLOAT, FLOAT)
};
static const int brush_settings_map_len = ARRAY_SIZE(brush_settings_map);

/* clang-format on */
#undef DEF

typedef struct BrushFlagMap {
  int member_offset;
  char *channel_name;
  int flag;
  int member_size;
} BrushFlagMap;

/* clang-format off */
#define DEF(member, channel, flag)\
  {offsetof(Brush, member), #channel, flag, sizeof(((Brush){0}).member)},

BrushFlagMap brush_flags_map[] =  {
  DEF(flag, ORIGINAL_NORMAL, BRUSH_ORIGINAL_NORMAL)
  DEF(flag, ORIGINAL_PLANE, BRUSH_ORIGINAL_PLANE)
  DEF(flag, ACCUMULATE, BRUSH_ACCUMULATE)
  DEF(flag2, USE_WEIGHTED_SMOOTH, BRUSH_SMOOTH_USE_AREA_WEIGHT)
  DEF(flag2, PRESERVE_FACESET_BOUNDARY, BRUSH_SMOOTH_PRESERVE_FACE_SETS)
  DEF(flag2, HARD_EDGE_MODE, BRUSH_HARD_EDGE_MODE)
  DEF(flag2, GRAB_SILHOUETTE, BRUSH_GRAB_SILHOUETTE)
};
int brush_flags_map_len = ARRAY_SIZE(brush_flags_map);

/* clang-format on */

static ATTR_NO_OPT void do_coerce(
    int type1, void *ptr1, int size1, int type2, void *ptr2, int size2)
{
  double val = 0;

  switch (type1) {
    case BRUSH_CHANNEL_FLOAT:
      val = *(float *)ptr1;
      break;
    case BRUSH_CHANNEL_INT:
    case BRUSH_CHANNEL_ENUM:
    case BRUSH_CHANNEL_BITMASK:
    case BRUSH_CHANNEL_BOOL:
      switch (size1) {
        case 1:
          val = (double)*(char *)ptr1;
          break;
        case 2:
          val = (double)*(unsigned short *)ptr1;
          break;
        case 4:
          val = (double)*(int *)ptr1;
          break;
        case 8:
          val = (double)*(int64_t *)ptr1;
          break;
      }
      break;
  }

  switch (type2) {
    case BRUSH_CHANNEL_FLOAT:
      *(float *)ptr2 = (float)val;
      break;
    case BRUSH_CHANNEL_INT:
    case BRUSH_CHANNEL_ENUM:
    case BRUSH_CHANNEL_BITMASK:
    case BRUSH_CHANNEL_BOOL: {
      switch (size2) {
        case 1:
          *(char *)ptr2 = (char)val;
          break;
        case 2:
          *(unsigned short *)ptr2 = (unsigned short)val;
          break;
        case 4:
          *(int *)ptr2 = (int)val;
          break;
        case 8:
          *(int64_t *)ptr2 = (int64_t)val;
          break;
      }
      break;
    }
  }
}

void *get_channel_value_pointer(BrushChannel *ch, int *r_data_size)
{
  *r_data_size = 4;

  switch (ch->type) {
    case BRUSH_CHANNEL_FLOAT:
      return &ch->fvalue;
    case BRUSH_CHANNEL_INT:
    case BRUSH_CHANNEL_ENUM:
    case BRUSH_CHANNEL_BITMASK:
    case BRUSH_CHANNEL_BOOL:
      return &ch->ivalue;
    case BRUSH_CHANNEL_VEC3:
      *r_data_size = sizeof(float) * 3;
      printf("implement me!\n");
      return NULL;
    case BRUSH_CHANNEL_VEC4:
      *r_data_size = sizeof(float) * 4;
      printf("implement me!\n");
      return NULL;
  }

  return NULL;
}

ATTR_NO_OPT void BKE_brush_channelset_compat_load(BrushChannelSet *chset,
                                                  Brush *brush,
                                                  bool brush_to_channels)
{
  for (int i = 0; i < brush_flags_map_len; i++) {
    BrushFlagMap *mf = brush_flags_map + i;
    BrushChannel *ch = BKE_brush_channelset_lookup(chset, mf->channel_name);

    if (!ch) {
      continue;
    }

    char *ptr = (char *)brush;
    ptr += mf->member_offset;

    switch (mf->member_size) {
      case 1: {
        char *f = (char *)ptr;
        ch->ivalue = (*f & mf->flag) ? 1 : 0;
        break;
      }
      case 2: {
        ushort *f = (ushort *)ptr;
        ch->ivalue = (*f & mf->flag) ? 1 : 0;
        break;
      }
      case 4: {
        uint *f = (uint *)ptr;
        ch->ivalue = (*f & mf->flag) ? 1 : 0;
        break;
      }
      case 8: {
        uint64_t *f = (uint64_t *)ptr;
        ch->ivalue = (*f & mf->flag) ? 1 : 0;
        break;
      }
    }
  }

  for (int i = 0; i < brush_settings_map_len; i++) {
    BrushSettingsMap *mp = brush_settings_map + i;
    BrushChannel *ch = BKE_brush_channelset_lookup(chset, mp->channel_name);

    if (!ch) {
      continue;
    }

    char *bptr = (char *)brush;
    bptr += mp->brush_offset;

    int csize;
    void *cptr = get_channel_value_pointer(ch, &csize);

    if (brush_to_channels) {
      do_coerce(mp->brush_type, bptr, mp->member_size, ch->type, cptr, csize);
    }
    else {
      do_coerce(ch->type, cptr, csize, mp->brush_type, bptr, mp->member_size);
    }
  }
}

BrushCommandList *BKE_brush_commandlist_create()
{
  return MEM_callocN(sizeof(BrushCommandList), "BrushCommandList");
}
void BKE_brush_commandlist_free(BrushCommandList *cl)
{
  for (int i = 0; i < cl->totcommand; i++) {
    BrushCommand *cmd = cl->commands + i;

    if (cmd->params) {
      BKE_brush_channelset_free(cmd->params);
    }

    if (cmd->params_final) {
      BKE_brush_channelset_free(cmd->params_final);
    }
  }

  MEM_SAFE_FREE(cl->commands);

  MEM_freeN(cl);
}
BrushCommand *BKE_brush_commandlist_add(BrushCommandList *cl,
                                        BrushChannelSet *chset_template,
                                        bool auto_inherit)
{
  cl->totcommand++;

  if (!cl->commands) {
    cl->commands = MEM_callocN(sizeof(BrushCommand) * cl->totcommand, "BrushCommand");
  }
  else {
    cl->commands = MEM_recallocN_id(
        cl->commands, sizeof(BrushCommand) * cl->totcommand, "cl->commands");
  }

  BrushCommand *cmd = cl->commands + cl->totcommand - 1;

  if (chset_template) {
    cmd->params = BKE_brush_channelset_copy(chset_template);

    for (int i = 0; auto_inherit && i < cmd->params->totchannel; i++) {
      BrushChannel *ch = cmd->params->channels + i;

      ch->flag |= BRUSH_CHANNEL_INHERIT;
    }
  }
  else {
    cmd->params = BKE_brush_channelset_create();
  }

  cmd->params_final = NULL;

  return cmd;
}

BrushCommand *BKE_brush_command_init(BrushCommand *command, int tool)
{
  BrushChannelSet *chset = command->params;

  namestack_push(__func__);

  command->tool = tool;

  ADDCH("SPACING");

  switch (tool) {
    case SCULPT_TOOL_DRAW:
      ADDCH("RADIUS");
      ADDCH("STRENGTH");
      break;
    case SCULPT_TOOL_SMOOTH:
      ADDCH("RADIUS");
      ADDCH("STRENGTH");
      ADDCH("FSET_SLIDE");
      ADDCH("BOUNDARY_SMOOTH");
      ADDCH("AUTOSMOOTH_PROJECTION");
      break;
    case SCULPT_TOOL_TOPOLOGY_RAKE:
      ADDCH("RADIUS");
      ADDCH("STRENGTH");
      // ADDCH("FSET_SLIDE");
      // ADDCH("BOUNDARY_SMOOTH");
      ADDCH("AUTOSMOOTH_PROJECTION");
      ADDCH("TOPOLOGY_RAKE_MODE");
      break;
    case SCULPT_TOOL_DYNTOPO:
      break;
  }

  namestack_pop();

  return command;
}

static void float_set_uninherit(BrushChannelSet *chset, const char *channel, float val)
{
  BrushChannel *ch = BKE_brush_channelset_lookup(chset, channel);

  if (!ch) {
    printf("%s: unknown channel %s\n", __func__, channel);
    return;
  }

  ch->fvalue = val;
  ch->flag &= ~BRUSH_CHANNEL_INHERIT;
}

ATTR_NO_OPT void BKE_builtin_commandlist_create(Brush *brush,
                                                BrushChannelSet *chset,
                                                BrushCommandList *cl,
                                                int tool,
                                                BrushMappingData *mapdata)
{
  BrushCommand *cmd;

  /* add main tool */

  cmd = BKE_brush_commandlist_add(cl, chset, true);
  BKE_brush_command_init(cmd, tool);

  float radius = BKE_brush_channelset_get_float(chset, "RADIUS", NULL);

  bool no_autosmooth = ELEM(
      brush->sculpt_tool, SCULPT_TOOL_BOUNDARY, SCULPT_TOOL_SMOOTH, SCULPT_TOOL_MASK);

  /* build autosmooth command */
  float autosmooth_scale = BKE_brush_channelset_get_float(chset, "AUTOSMOOTH_RADIUS_SCALE", NULL);
  float autosmooth_projection = BKE_brush_channelset_get_float(
      chset, "TOPOLOGY_RAKE_PROJECTION", NULL);

  float autosmooth_spacing;

  if (BKE_brush_channelset_get_int(chset, "AUTOSMOOTH_USE_SPACING")) {
    autosmooth_spacing = BKE_brush_channelset_get_float(chset, "AUTOSMOOTH_SPACING", NULL);
  }
  else {
    autosmooth_spacing = BKE_brush_channelset_get_float(chset, "SPACING", NULL);
  }

  float autosmooth = BKE_brush_channelset_get_float(chset, "AUTOSMOOTH", NULL);
  if (!no_autosmooth && autosmooth > 0.0f) {
    cmd = BKE_brush_command_init(BKE_brush_commandlist_add(cl, brush->channels, true),
                                 SCULPT_TOOL_SMOOTH);
    float_set_uninherit(cmd->params, "STRENGTH", autosmooth);
    float_set_uninherit(cmd->params, "RADIUS", radius * autosmooth_scale);
    float_set_uninherit(cmd->params, "PROJECTION", autosmooth_projection);
    float_set_uninherit(cmd->params, "SPACING", autosmooth_spacing);
  }

  float topology_rake_scale = BKE_brush_channelset_get_float(
      chset, "TOPOLOGY_RAKE_RADIUS_SCALE", NULL);
  float topology_rake_projection = BKE_brush_channelset_get_float(
      chset, "TOPOLOGY_RAKE_PROJECTION", NULL);

  /* build topology rake command*/
  float topology_rake = BKE_brush_channelset_get_float(chset, "TOPOLOGY_RAKE", NULL);
  float topology_rake_spacing;

  if (BKE_brush_channelset_get_int(chset, "TOPOLOGY_RAKE_USE_SPACING")) {
    topology_rake_spacing = BKE_brush_channelset_get_float(chset, "TOPOLOGY_RAKE_SPACING", NULL);
  }
  else {
    topology_rake_spacing = BKE_brush_channelset_get_float(chset, "SPACING", NULL);
  }

  if (topology_rake > 0.0f) {
    cmd = BKE_brush_command_init(BKE_brush_commandlist_add(cl, brush->channels, true),
                                 SCULPT_TOOL_SMOOTH);

    float_set_uninherit(cmd->params, "STRENGTH", topology_rake);
    float_set_uninherit(cmd->params, "RADIUS", radius * topology_rake_scale);
    float_set_uninherit(cmd->params, "PROJECTION", topology_rake_projection);
    float_set_uninherit(cmd->params, "SPACING", topology_rake_spacing);
  }

  /* build dyntopo command */

  if (!BKE_brush_channelset_get_int(chset, "DYNTOPO_DISABLED")) {
    cmd = BKE_brush_command_init(BKE_brush_commandlist_add(cl, brush->channels, true),
                                 SCULPT_TOOL_DYNTOPO);
  }
  // if (!BKE_brush_channelset_get_int)
}

void BKE_brush_channelset_read(BlendDataReader *reader, BrushChannelSet *cset)
{
  BLO_read_data_address(reader, &cset->channels);

  // drop any queued channels, we don't save them.
  cset->queued_channels = NULL;
  cset->tot_queued_channel = 0;

  for (int i = 0; i < cset->totchannel; i++) {
    BrushChannel *ch = cset->channels + i;

    for (int j = 0; j < BRUSH_MAPPING_MAX; j++) {
      BKE_curvemapping_blend_read(reader, &ch->mappings[j].curve);
      BKE_curvemapping_init(&ch->mappings[j].curve);

      check_corrupted_curve(ch->mappings + j);

      // paranoia check to make sure BrushMapping.type is correct
      ch->mappings[j].type = j;
    }

    ch->def = BKE_brush_builtin_channel_def_find(ch->idname);

    if (!ch->def) {
      printf("failed to find brush definition");
      ch->def = BKE_brush_default_channel_def();
    }
    else {
      // ensure ->type is correct
      ch->type = ch->def->type;
    }
  }
}

ATTR_NO_OPT void BKE_brush_channelset_write(BlendWriter *writer, BrushChannelSet *cset)
{
  BLO_write_struct(writer, BrushChannelSet, cset);
  BLO_write_struct_array_by_name(writer, "BrushChannel", cset->totchannel, cset->channels);

  for (int i = 0; i < cset->totchannel; i++) {
    BrushChannel *ch = cset->channels + i;

    for (int j = 0; j < BRUSH_MAPPING_MAX; j++) {
      BKE_curvemapping_blend_write(writer, &ch->mappings[j].curve);
    }
  }
}

const char *BKE_brush_mapping_type_to_str(BrushMappingType mapping)
{
  switch (mapping) {
    case BRUSH_MAPPING_PRESSURE:
      return "Pressure";
    case BRUSH_MAPPING_ANGLE:
      return "Angle";
    case BRUSH_MAPPING_SPEED:
      return "Speed";
    case BRUSH_MAPPING_XTILT:
      return "X Tilt";
    case BRUSH_MAPPING_YTILT:
      return "Y Tilt";
    case BRUSH_MAPPING_MAX:
      return "Error";
  }

  return "Error";
}

const char *BKE_brush_mapping_type_to_typename(BrushMappingType mapping)
{
  switch (mapping) {
    case BRUSH_MAPPING_PRESSURE:
      return "PRESSURE";
    case BRUSH_MAPPING_ANGLE:
      return "ANGLE";
    case BRUSH_MAPPING_SPEED:
      return "SPEED";
    case BRUSH_MAPPING_XTILT:
      return "XTILT";
    case BRUSH_MAPPING_YTILT:
      return "YTILT";
    case BRUSH_MAPPING_MAX:
      return "Error";
  }

  return "Error";
}

void BKE_brush_mapping_copy_data(BrushMapping *dst, BrushMapping *src)
{
  BKE_curvemapping_free_data(&dst->curve);

  // do not copy .type
  int type = dst->type;
  *dst = *src;
  dst->type = type;

  namestack_push(__func__);

  BKE_curvemapping_copy_data(&dst->curve, &src->curve);
  BKE_curvemapping_init(&dst->curve);

  check_corrupted_curve(dst);

  namestack_pop();
}

void BKE_brush_channelset_to_unified_settings(BrushChannelSet *chset, UnifiedPaintSettings *ups)
{
  BrushChannel *ch;

  if (ch = BKE_brush_channelset_lookup(chset, "RADIUS")) {
    ups->size = ch->fvalue;
  }

  if (ch = BKE_brush_channelset_lookup(chset, "STRENGTH")) {
    ups->alpha = ch->fvalue;
  }

  if (ch = BKE_brush_channelset_lookup(chset, "WEIGHT")) {
    ups->weight = ch->fvalue;
  }
}
/* idea for building built-in preset node graphs:
from brush_builder import Builder;

def build(input, output):
  input.add("Strength", "float", "strength").range(0.0, 3.0)
  input.add("Radius", "float", "radius").range(0.01, 1024.0)
  input.add("Autosmooth", "float", "autosmooth").range(0.0, 4.0)
  input.add("Topology Rake", "float", "topology rake").range(0.0, 4.0)
  input.add("Smooth Radius Scale", "float", "autosmooth_radius_scale").range(0.01, 5.0)
  input.add("Rake Radius Scale", "float", "toporake_radius_scale").range(0.01, 5.0)

  draw = input.make.tool("DRAW")
  draw.radius = input.radius
  draw.strength = input.strength

  smooth = input.make.tool("SMOOTH")
  smooth.radius = input.radius * input.autosmooth_radius_scale
  smooth.strength = input.autosmooth;
  smooth.flow = draw.outflow

  rake = input.make.tool("TOPORAKE")
  rake.radius = input.radius * input.toporake_radius_scale
  rake.strength = input.topology;
  rake.flow = smooth.outflow

  output.out = rake.outflow

preset = Builder(build)

*/

/*
bNodeType sculpt_tool_node = {
  .idname = "SculptTool",
  .ui_name = "SculptTool",
};*/
/* cland-format on */
